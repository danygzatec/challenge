{"ast":null,"code":"/*\nCopyright (c) 2019 Daybrush\nname: @scena/dragscroll\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/dragscroll.git\nversion: 1.3.0\n*/\nimport EventEmitter from '@scena/event-emitter';\nimport { now, isString, isFunction } from '@daybrush/utils';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction getDefaultScrollPosition(e) {\n  var container = e.container;\n  if (container === document.body) {\n    return [container.scrollLeft || document.documentElement.scrollLeft, container.scrollTop || document.documentElement.scrollTop];\n  }\n  return [container.scrollLeft, container.scrollTop];\n}\nfunction getContainerElement(container) {\n  if (!container) {\n    return null;\n  } else if (isString(container)) {\n    return document.querySelector(container);\n  }\n  if (isFunction(container)) {\n    return container();\n  } else if (container instanceof Element) {\n    return container;\n  } else if (\"current\" in container) {\n    return container.current;\n  } else if (\"value\" in container) {\n    return container.value;\n  }\n}\n/**\n * @sort 1\n */\n\nvar DragScroll = /*#__PURE__*/\nfunction (_super) {\n  __extends(DragScroll, _super);\n  function DragScroll() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this._startRect = null;\n    _this._startPos = [];\n    _this._prevTime = 0;\n    _this._timer = 0;\n    _this._prevScrollPos = [0, 0];\n    _this._isWait = false;\n    _this._flag = false;\n    return _this;\n  }\n  /**\n   */\n\n  var __proto = DragScroll.prototype;\n  __proto.dragStart = function (e, options) {\n    var container = getContainerElement(options.container);\n    if (!container) {\n      this._flag = false;\n      return;\n    }\n    var top = 0;\n    var left = 0;\n    var width = 0;\n    var height = 0;\n    if (container === document.body) {\n      width = window.innerWidth;\n      height = window.innerHeight;\n    } else {\n      var rect = container.getBoundingClientRect();\n      top = rect.top;\n      left = rect.left;\n      width = rect.width;\n      height = rect.height;\n    }\n    this._flag = true;\n    this._startPos = [e.clientX, e.clientY];\n    this._startRect = {\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    };\n    this._prevScrollPos = this._getScrollPosition([0, 0], options);\n  };\n  __proto.drag = function (e, options) {\n    clearTimeout(this._timer);\n    if (!this._flag) {\n      return;\n    }\n    var clientX = e.clientX,\n      clientY = e.clientY;\n    var _a = options.threshold,\n      threshold = _a === void 0 ? 0 : _a;\n    var _b = this,\n      _startRect = _b._startRect,\n      _startPos = _b._startPos;\n    var direction = [0, 0];\n    if (_startRect.top > clientY - threshold) {\n      if (_startPos[1] > _startRect.top || clientY < _startPos[1]) {\n        direction[1] = -1;\n      }\n    } else if (_startRect.top + _startRect.height < clientY + threshold) {\n      if (_startPos[1] < _startRect.top + _startRect.height || clientY > _startPos[1]) {\n        direction[1] = 1;\n      }\n    }\n    if (_startRect.left > clientX - threshold) {\n      if (_startPos[0] > _startRect.left || clientX < _startPos[0]) {\n        direction[0] = -1;\n      }\n    } else if (_startRect.left + _startRect.width < clientX + threshold) {\n      if (_startPos[0] < _startRect.left + _startRect.width || clientX > _startPos[0]) {\n        direction[0] = 1;\n      }\n    }\n    if (!direction[0] && !direction[1]) {\n      return false;\n    }\n    return this._continueDrag(__assign(__assign({}, options), {\n      direction: direction,\n      inputEvent: e,\n      isDrag: true\n    }));\n  };\n  /**\n   */\n\n  __proto.checkScroll = function (options) {\n    var _this = this;\n    if (this._isWait) {\n      return false;\n    }\n    var _a = options.prevScrollPos,\n      prevScrollPos = _a === void 0 ? this._prevScrollPos : _a,\n      direction = options.direction,\n      _b = options.throttleTime,\n      throttleTime = _b === void 0 ? 0 : _b,\n      inputEvent = options.inputEvent,\n      isDrag = options.isDrag;\n    var nextScrollPos = this._getScrollPosition(direction || [0, 0], options);\n    var offsetX = nextScrollPos[0] - prevScrollPos[0];\n    var offsetY = nextScrollPos[1] - prevScrollPos[1];\n    var nextDirection = direction || [offsetX ? Math.abs(offsetX) / offsetX : 0, offsetY ? Math.abs(offsetY) / offsetY : 0];\n    this._prevScrollPos = nextScrollPos;\n    if (!offsetX && !offsetY) {\n      return false;\n    }\n    /**\n     * @event DragScroll#move\n     */\n\n    this.trigger(\"move\", {\n      offsetX: nextDirection[0] ? offsetX : 0,\n      offsetY: nextDirection[1] ? offsetY : 0,\n      inputEvent: inputEvent\n    });\n    if (throttleTime && isDrag) {\n      clearTimeout(this._timer);\n      this._timer = window.setTimeout(function () {\n        _this._continueDrag(options);\n      }, throttleTime);\n    }\n    return true;\n  };\n  /**\n   */\n\n  __proto.dragEnd = function () {\n    this._flag = false;\n    clearTimeout(this._timer);\n  };\n  __proto._getScrollPosition = function (direction, options) {\n    var container = options.container,\n      _a = options.getScrollPosition,\n      getScrollPosition = _a === void 0 ? getDefaultScrollPosition : _a;\n    return getScrollPosition({\n      container: getContainerElement(container),\n      direction: direction\n    });\n  };\n  __proto._continueDrag = function (options) {\n    var _this = this;\n    var _a, _b;\n    var container = options.container,\n      direction = options.direction,\n      throttleTime = options.throttleTime,\n      useScroll = options.useScroll,\n      isDrag = options.isDrag,\n      inputEvent = options.inputEvent;\n    if (!this._flag || isDrag && this._isWait) {\n      return;\n    }\n    var nowTime = now();\n    var distTime = Math.max(throttleTime + this._prevTime - nowTime, 0);\n    if (distTime > 0) {\n      clearTimeout(this._timer);\n      this._timer = window.setTimeout(function () {\n        _this._continueDrag(options);\n      }, distTime);\n      return false;\n    }\n    this._prevTime = nowTime;\n    var prevScrollPos = this._getScrollPosition(direction, options);\n    this._prevScrollPos = prevScrollPos;\n    if (isDrag) {\n      this._isWait = true;\n    }\n    var param = {\n      container: getContainerElement(container),\n      direction: direction,\n      inputEvent: inputEvent\n    };\n    (_b = (_a = options).requestScroll) === null || _b === void 0 ? void 0 : _b.call(_a, param);\n    /**\n     * @event DragScroll#scroll\n     */\n\n    this.trigger(\"scroll\", param);\n    this._isWait = false;\n    return useScroll || this.checkScroll(__assign(__assign({}, options), {\n      prevScrollPos: prevScrollPos,\n      direction: direction,\n      inputEvent: inputEvent\n    }));\n  };\n  return DragScroll;\n}(EventEmitter);\nexport default DragScroll;","map":{"version":3,"mappings":"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","names":["getDefaultScrollPosition","e","container","document","body","scrollLeft","documentElement","scrollTop","getContainerElement","isString","querySelector","isFunction","Element","current","value","__extends","_this","options","_flag","top","left","width","height","window","innerWidth","innerHeight","rect","getBoundingClientRect","_startPos","clientX","clientY","_startRect","_prevScrollPos","_getScrollPosition","clearTimeout","_timer","_a","threshold","_b","direction","_continueDrag","inputEvent","isDrag","_isWait","prevScrollPos","throttleTime","nextScrollPos","offsetX","offsetY","nextDirection","Math","abs","trigger","setTimeout","getScrollPosition","useScroll","nowTime","now","distTime","max","_prevTime","param","requestScroll","checkScroll","EventEmitter"],"sources":["/Users/danygarza/Desktop/challenge/front-challenge-2/node_modules/@scena/dragscroll/src/DragScroll.ts"],"sourcesContent":["import EventEmitter from \"@scena/event-emitter\";\nimport { isFunction, isString, now } from \"@daybrush/utils\";\nimport { CheckScrollOptions, DragScrollEvents, DragScrollOptions, Rect } from \"./types\";\n\nfunction getDefaultScrollPosition(e: { container: HTMLElement, direction: number[] }) {\n    let container = e.container;\n\n    if (container === document.body) {\n        return [\n            container.scrollLeft || document.documentElement.scrollLeft,\n            container.scrollTop || document.documentElement.scrollTop,\n        ];\n    }\n    return [\n        container.scrollLeft,\n        container.scrollTop,\n    ];\n}\n\nfunction getContainerElement(container: DragScrollOptions[\"container\"]): HTMLElement {\n    if (!container) {\n        return null;\n    } else if (isString(container)) {\n        return document.querySelector<HTMLElement>(container);\n    } if (isFunction(container)) {\n        return container();\n    } else if (container instanceof Element) {\n        return container;\n    } else if (\"current\" in container) {\n        return container.current;\n    } else if (\"value\" in container) {\n        return container.value;\n    }\n}\n\n/**\n * @sort 1\n */\nclass DragScroll extends EventEmitter<DragScrollEvents> {\n    private _startRect: Rect | null = null;\n    private _startPos: number[] = [];\n    private _prevTime: number = 0;\n    private _timer: number = 0;\n    private _prevScrollPos: number[] = [0, 0];\n    private _isWait = false;\n    private _flag = false;\n    /**\n     */\n    public dragStart(e: any, options: DragScrollOptions) {\n        const container = getContainerElement(options.container);\n\n        if (!container) {\n            this._flag = false;\n            return;\n        }\n        let top = 0;\n        let left = 0;\n        let width = 0;\n        let height = 0;\n\n        if (container === document.body) {\n            width = window.innerWidth;\n            height = window.innerHeight;\n        } else {\n            const rect = container.getBoundingClientRect();\n\n            top = rect.top;\n            left = rect.left;\n            width = rect.width;\n            height = rect.height;\n        }\n\n        this._flag = true;\n        this._startPos = [e.clientX, e.clientY];\n        this._startRect = { top, left, width, height };\n        this._prevScrollPos = this._getScrollPosition([0, 0], options);\n    }\n    public drag(e: any, options: DragScrollOptions) {\n        clearTimeout(this._timer);\n        if (!this._flag) {\n            return;\n        }\n        const {\n            clientX,\n            clientY,\n        } = e;\n        const {\n            threshold = 0,\n        } = options;\n        const {\n            _startRect,\n            _startPos,\n        } = this;\n\n        const direction = [0, 0];\n\n        if (_startRect.top > clientY - threshold) {\n            if (_startPos[1] > _startRect.top || clientY < _startPos[1]) {\n                direction[1] = -1;\n            }\n        } else if (_startRect.top + _startRect.height < clientY + threshold) {\n            if (_startPos[1] < _startRect.top + _startRect.height || clientY > _startPos[1]) {\n                direction[1] = 1;\n            }\n        }\n        if (_startRect.left > clientX - threshold) {\n            if (_startPos[0] > _startRect.left || clientX < _startPos[0]) {\n                direction[0] = -1;\n            }\n        } else if (_startRect.left + _startRect.width < clientX + threshold) {\n            if (_startPos[0] < _startRect.left + _startRect.width || clientX > _startPos[0]) {\n                direction[0] = 1;\n            }\n        }\n\n        if (!direction[0] && !direction[1]) {\n            return false;\n        }\n        return this._continueDrag({\n            ...options,\n            direction,\n            inputEvent: e,\n            isDrag: true,\n        });\n    }\n    /**\n     */\n    public checkScroll(options: CheckScrollOptions) {\n        if (this._isWait) {\n            return false;\n        }\n        const {\n            prevScrollPos = this._prevScrollPos,\n            direction,\n            throttleTime = 0,\n            inputEvent,\n            isDrag,\n        } = options;\n        const nextScrollPos = this._getScrollPosition(direction || [0, 0], options);\n        const offsetX = nextScrollPos[0] - prevScrollPos[0];\n        const offsetY = nextScrollPos[1] - prevScrollPos[1];\n\n        const nextDirection = direction || [\n            offsetX ? Math.abs(offsetX) / offsetX : 0,\n            offsetY ? Math.abs(offsetY) / offsetY : 0,\n        ];\n        this._prevScrollPos = nextScrollPos;\n\n        if (!offsetX && !offsetY) {\n            return false;\n        }\n        /**\n         * @event DragScroll#move\n         */\n        this.trigger(\"move\", {\n            offsetX: nextDirection[0] ? offsetX : 0,\n            offsetY: nextDirection[1] ? offsetY : 0,\n            inputEvent,\n        });\n\n        if (throttleTime && isDrag) {\n            clearTimeout(this._timer);\n            this._timer = window.setTimeout(() => {\n                this._continueDrag(options);\n            }, throttleTime);\n        }\n        return true;\n    }\n    /**\n     */\n    public dragEnd() {\n        this._flag = false;\n        clearTimeout(this._timer);\n    }\n    private _getScrollPosition(direction: number[], options: DragScrollOptions) {\n        const {\n            container,\n            getScrollPosition = getDefaultScrollPosition,\n        } = options;\n        return getScrollPosition({ container: getContainerElement(container), direction });\n    }\n    private _continueDrag(options: CheckScrollOptions) {\n        const {\n            container,\n            direction,\n            throttleTime,\n            useScroll,\n            isDrag,\n            inputEvent,\n        } = options;\n\n        if (!this._flag || (isDrag && this._isWait)) {\n            return;\n        }\n        const nowTime = now();\n        const distTime = Math.max(throttleTime + this._prevTime - nowTime, 0);\n\n        if (distTime > 0) {\n            clearTimeout(this._timer);\n            this._timer = window.setTimeout(() => {\n                this._continueDrag(options);\n            }, distTime);\n\n            return false;\n        }\n\n        this._prevTime = nowTime;\n        const prevScrollPos = this._getScrollPosition(direction, options);\n\n        this._prevScrollPos = prevScrollPos;\n\n        if (isDrag) {\n            this._isWait = true;\n        }\n        const param = {\n            container: getContainerElement(container),\n            direction,\n            inputEvent,\n        };\n        options.requestScroll?.(param);\n        /**\n         * @event DragScroll#scroll\n         */\n        this.trigger(\"scroll\", param);\n\n        this._isWait = false;\n        return useScroll || this.checkScroll({\n            ...options,\n            prevScrollPos,\n            direction,\n            inputEvent,\n        });\n    }\n}\n\nexport default DragScroll;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}